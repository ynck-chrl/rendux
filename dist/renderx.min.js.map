{"version":3,"file":"renderx.min.js","sources":["../src/renderx.js"],"sourcesContent":["// --- Mini Evaluator inlined ---\n/*\n * js/miniEvaluator.js\n * A tiny expression parser and evaluator for renderx directives.\n */\n\n// Whitelisted global objects\nconst GLOBALS = { Math, Date, Number, String, Boolean, JSON, parseInt, parseFloat, isFinite, Array };\n\n/**\n * Evaluate a JS-like expression in a sandboxed context.\n * Supports literals, identifier/member access, function calls,\n * unary/binary/logical operators, and ternary.\n *\n * @param {string} expr - The expression string to evaluate.\n * @param {object} ctx - Context object: properties and helpers; ctx.this is the evaluation `this`.\n * @returns {any} - The evaluated result.\n */\nfunction evalExpr(expr, ctx = {}) {\n  const tokens = tokenize(expr);\n  let index = 0;\n\n  function peek() { return tokens[index] || { type: 'EOF' }; }\n  function next() { return tokens[index++] || { type: 'EOF' }; }\n  function expect(type, value) {\n    const tok = peek();\n    if (tok.type !== type || (value !== undefined && tok.value !== value)) {\n      throw new Error(`Expected ${value || type} but got ${tok.value}`);\n    }\n    next();\n    return tok;\n  }\n  function isOperator(op) {\n    const t = peek();\n    return t.type === 'operator' && t.value === op;\n  }\n\n  // Entry point: parse conditional expression\n  const result = parseConditional();\n  if (peek().type !== 'EOF') {\n    throw new Error(`Unexpected token: ${peek().value}`);\n  }\n  return result;\n\n  // Grammar:\n  // conditionalExpr ::= logicalOrExpr ('?' conditionalExpr ':' conditionalExpr)?\n  // logicalOrExpr   ::= logicalAndExpr ( '||' logicalAndExpr )*\n  // logicalAndExpr  ::= equalityExpr ( '&&' equalityExpr )*\n  // equalityExpr    ::= relationalExpr ( ('==' | '!=' | '===' | '!==') relationalExpr )*\n  // relationalExpr  ::= additiveExpr ( ('>' | '<' | '>=' | '<=') additiveExpr )*\n  // additiveExpr    ::= multiplicativeExpr ( ('+' | '-') multiplicativeExpr )*\n  // multiplicativeExpr ::= unaryExpr ( ('*' | '/' | '%') unaryExpr )*\n  // unaryExpr       ::= ('!' | '+' | '-') unaryExpr | primary\n  // primary         ::= literal | identifier ( member / call )* | '(' conditionalExpr ')'\n\n  function parseConditional() {\n    let val = parseLogicalOr();\n    if (isOperator('?')) {\n      next();\n      const trueVal = parseConditional();\n      expect('operator', ':');\n      const falseVal = parseConditional();\n      val = val ? trueVal : falseVal;\n    }\n    return val;\n  }\n\n  function parseLogicalOr() {\n    let val = parseLogicalAnd();\n    while (isOperator('||')) {\n      next();\n      const right = parseLogicalAnd();\n      val = val || right;\n    }\n    return val;\n  }\n\n  function parseLogicalAnd() {\n    let val = parseEquality();\n    while (isOperator('&&')) {\n      next();\n      const right = parseEquality();\n      val = val && right;\n    }\n    return val;\n  }\n\n  function parseEquality() {\n    let val = parseRelational();\n    while (['==','!=','===','!=='].includes(peek().value)) {\n      const op = next().value;\n      const right = parseRelational();\n      switch (op) {\n        case '==':  val = val == right;  break;\n        case '!=':  val = val != right;  break;\n        case '===': val = val === right; break;\n        case '!==': val = val !== right; break;\n      }\n    }\n    return val;\n  }\n\n  function parseRelational() {\n    let val = parseAdditive();\n    while (['>','<','>=','<='].includes(peek().value)) {\n      const op = next().value;\n      const right = parseAdditive();\n      switch (op) {\n        case '>':  val = val > right;  break;\n        case '<':  val = val < right;  break;\n        case '>=': val = val >= right; break;\n        case '<=': val = val <= right; break;\n      }\n    }\n    return val;\n  }\n\n  function parseAdditive() {\n    let val = parseMultiplicative();\n    while (['+','-'].includes(peek().value)) {\n      const op = next().value;\n      const right = parseMultiplicative();\n      val = (op === '+') ? (val + right) : (val - right);\n    }\n    return val;\n  }\n\n  function parseMultiplicative() {\n    let val = parseUnary();\n    while (['*','/','%'].includes(peek().value)) {\n      const op = next().value;\n      const right = parseUnary();\n      switch (op) {\n        case '*': val = val * right; break;\n        case '/': val = val / right; break;\n        case '%': val = val % right; break;\n      }\n    }\n    return val;\n  }\n\n  function parseUnary() {\n    if (['!','+','-'].includes(peek().value)) {\n      const op = next().value;\n      const val = parseUnary();\n      switch (op) {\n        case '!': return !val;\n        case '+': return +val;\n        case '-': return -val;\n      }\n    }\n    return parsePrimary();\n  }\n\n  function parsePrimary() {\n    const tok = peek();\n    // literals\n    if (tok.type === 'number' || tok.type === 'string' || tok.type === 'boolean' || tok.type === 'null') {\n      next();\n      return tok.value;\n    }\n    // identifier + member/call\n    if (tok.type === 'identifier') {\n      next();\n      let val = resolveIdentifier(tok.value);\n      while (true) {\n        if (isOperator('.')) {\n          next();\n          const prop = expect('identifier').value;\n          val = (val == null) ? undefined : val[prop];\n        } else if (isOperator('[')) {\n          next();\n          const idx = parseConditional();\n          expect('operator', ']');\n          val = (val == null) ? undefined : val[idx];\n        } else if (isOperator('(')) {\n          next();\n          const args = [];\n          if (!isOperator(')')) {\n            do {\n              args.push(parseConditional());\n            } while (isOperator(',') && next());\n          }\n          expect('operator', ')');\n          if (typeof val !== 'function') {\n            throw new Error(`'${tok.value}' is not a function`);\n          }\n          val = val.apply(ctx.this, args);\n        } else {\n          break;\n        }\n      }\n      return val;\n    }\n    // grouping\n    if (isOperator('(')) {\n      next();\n      const val = parseConditional();\n      expect('operator', ')');\n      return val;\n    }\n    throw new Error(`Unexpected token: ${tok.value}`);\n  }\n\n  function resolveIdentifier(name) {\n    if (name in ctx) return ctx[name];\n    if (name in GLOBALS) return GLOBALS[name];\n    if (ctx.this != null && name in ctx.this) return ctx.this[name];\n    throw new Error(`Unknown identifier: ${name}`);\n  }\n\n  // Lexer: tokenize input string into a list of token objects\n  function tokenize(str) {\n    const tokens = [];\n    let i = 0;\n    while (i < str.length) {\n      let ch = str[i];\n      if (/\\s/.test(ch)) { i++; continue; }\n      // string literal\n      if (ch === '\"' || ch === \"'\") {\n        const quote = ch;\n        let val = '';\n        i++;\n        while (i < str.length && str[i] !== quote) {\n          if (str[i] === '\\\\') {\n            i++;\n            if (i < str.length) {\n              val += str[i++];\n            }\n          } else {\n            val += str[i++];\n          }\n        }\n        i++;\n        tokens.push({ type: 'string', value: val });\n        continue;\n      }\n      // number literal\n      if (/[0-9]/.test(ch) || (ch === '.' && /[0-9]/.test(str[i+1]))) {\n        let start = i;\n        while (i < str.length && /[0-9]/.test(str[i])) i++;\n        if (str[i] === '.') {\n          i++;\n          while (i < str.length && /[0-9]/.test(str[i])) i++;\n        }\n        const num = parseFloat(str.slice(start, i));\n        tokens.push({ type: 'number', value: num });\n        continue;\n      }\n      // identifier or boolean or null\n      if (/[a-zA-Z_$]/.test(ch)) {\n        let start = i;\n        i++;\n        while (i < str.length && /[a-zA-Z0-9_$]/.test(str[i])) i++;\n        const name = str.slice(start, i);\n        if (name === 'true' || name === 'false') {\n          tokens.push({ type: 'boolean', value: name === 'true' });\n        } else if (name === 'null') {\n          tokens.push({ type: 'null', value: null });\n        } else {\n          tokens.push({ type: 'identifier', value: name });\n        }\n        continue;\n      }\n      // multi-char operators\n      const two = str.substr(i, 2);\n      const three = str.substr(i, 3);\n      if (['===','!=='].includes(three)) {\n        tokens.push({ type: 'operator', value: three });\n        i += 3;\n        continue;\n      }\n      if (['==','!=','>=','<=','&&','||'].includes(two)) {\n        tokens.push({ type: 'operator', value: two });\n        i += 2;\n        continue;\n      }\n      // single-char operators / punctuation\n      if (['+', '-', '*', '/', '%', '>', '<', '!', '?', ':', '(', ')', '[', ']', '.', ',',].includes(ch)) {\n        tokens.push({ type: 'operator', value: ch });\n        i++;\n        continue;\n      }\n      throw new Error(`Invalid character '${ch}' in expression`);\n    }\n    tokens.push({ type: 'EOF' });\n    return tokens;\n  }\n}\n// --- End Mini Evaluator ---\n\n// --- Plugin core inlined ---\nconst plugins = new Map();\n\nfunction usePlugin(plugin) {\n  if (!plugin || !plugin.name) throw new Error('Invalid plugin');\n  plugins.set(plugin.name, plugin);\n}\n\nfunction parsePluginCall(call, ctx = {}) {\n  const m = call.match(/^([a-zA-Z_$][\\w$]*)\\s*\\(\\s*(.*)\\s*\\)$/);\n  if (!m) return null;\n  const name = m[1];\n  const plugin = plugins.get(name);\n  if (!plugin) return null;\n  const argsString = m[2].trim();\n  if (argsString === '') return { plugin, args: [] };\n  const parts = argsString.split(/\\s*,\\s*/);\n  const args = parts.map(p => {\n    if ((p.startsWith('\"') && p.endsWith('\"')) || (p.startsWith(\"'\") && p.endsWith(\"'\"))) {\n      return p.slice(1, -1);\n    } else if (/^-?\\d+(?:\\.\\d+)?$/.test(p)) {\n      return parseFloat(p);\n    } else if (p in ctx) {\n      return ctx[p];\n    } else {\n      throw new Error(`Unknown identifier: ${p}`);\n    }\n  });\n  return { plugin, args };\n}\n\nasync function processPlugins(root = document, ctx = {}) {\n  // Find all elements with a render.* attribute\n  const els = Array.from(root.querySelectorAll('*')).filter(el =>\n    Array.from(el.attributes).some(a => a.name.startsWith('render.'))\n  );\n  for (const el of els) {\n    // For each render.* attribute on this element\n    for (const a of Array.from(el.attributes)) {\n      if (!a.name.startsWith('render.')) continue;\n      const attrName = a.name;\n      const rawValue = a.value.trim();\n      let plugin, args;\n      if (attrName === 'render.plugin') {\n        // Generic plugin attribute: parse plugin name from call value\n        let parsed;\n        try { parsed = parsePluginCall(rawValue, ctx); }\n        catch(e) { console.error(e); continue; }\n        if (!parsed) continue;\n        plugin = parsed.plugin;\n        args = parsed.args;\n      } else {\n        // Specific plugin attribute: render.<pluginName>\n        const pluginName = attrName.slice('render.'.length);\n        plugin = plugins.get(pluginName);\n        if (!plugin) continue;\n        // If rawValue uses call syntax, parse it\n        if (rawValue.startsWith(pluginName + '(')) {\n          let parsed;\n          try { parsed = parsePluginCall(rawValue, ctx); }\n          catch(e) { console.error(e); continue; }\n          if (!parsed) continue;\n          // parsed.plugin.name should match pluginName\n          plugin = parsed.plugin;\n          args = parsed.args;\n        } else {\n          // Bare value passed as first argument\n          args = [rawValue];\n        }\n      }\n      // Execute plugin\n      // ─── PER-ELEMENT BEFORE HOOK ─────────────────────────────────────────\n      if (typeof plugin.onBeforeExecute === 'function') {\n        plugin.onBeforeExecute(el, rawValue, ctx);\n      }\n      let result;\n      try { \n        result = plugin.execute(...args); \n      }\n      catch(e) {\n        continue; \n      }\n      el.textContent = result == null ? '' : String(result);\n      // Keep plugin attributes for re-rendering\n      // ─── PER-ELEMENT AFTER HOOK ──────────────────────────────────────────\n      if (typeof plugin.onAfterExecute === 'function') {\n        plugin.onAfterExecute(el, rawValue, ctx);\n      }\n    }\n  }\n  // ─── GLOBAL AFTER RENDER HOOK ──────────────────────────────────────────\n  for (const plugin of plugins.values()) {\n    if (typeof plugin.onAfterRender === 'function') {\n      await plugin.onAfterRender(root, ctx);\n    }\n  }\n}\n// --- End plugin core ---\n\nexport function renderx(root = this.shadowRoot || this) {\n  const component = this;\n  // ─── GLOBAL BEFORE RENDER HOOK (snapshot before x-for/x-if) ───────────────\n  for (const plugin of plugins.values()) {\n    if (typeof plugin.onBeforeRender === 'function') {\n      plugin.onBeforeRender(root, component);\n    }\n  }\n  const documentRef = document;\n\n  // ─── PARSE logs ATTRIBUTE ────────────────────────────────────────────────────\n  const logsAttr = component.getAttribute('logs');\n  const doLogs   = Boolean(logsAttr);\n  const logsSet  = logsAttr\n    ? new Set(logsAttr.split(',').map(s => s.trim().toLowerCase()))\n    : new Set();\n  const skipCleanup = feat =>\n    logsSet.has('all')\n    || logsSet.has(feat.toLowerCase())\n    || logsSet.has(('x-' + feat).toLowerCase());\n  const doPluginsLogs = doLogs && logsSet.has('plugins');\n  const log  = (...a) => { if (doLogs) console.log(...a); };\n  const warn = (...a) => console.warn(...a);\n\n  // ─── CACHES & MIRROR CONTAINER ────────────────────────────────────────────────\n  if (!component._xRenderCache) component._xRenderCache = new Map();\n  if (!component._xRenderOriginalText) component._xRenderOriginalText = new WeakMap();\n  if (!component._xIfData) component._xIfData = new WeakMap();\n  if (!component._cloneContext) component._cloneContext = new WeakMap();\n  if (!component._xClassCache) component._xClassCache = new Map();\n  if (!component._xForCache) component._xForCache = new WeakMap();\n\n  if (!component.__mirrorContainer) {\n    component.__mirrorContainer = documentRef.createDocumentFragment();\n  }\n\n  // ─── HELPERS ─────────────────────────────────────────────────────────────────\n  const helpers = {};\n  Object.getOwnPropertyNames(Object.getPrototypeOf(component)).forEach(k => {\n    if (typeof component[k] === 'function' && k !== 'constructor') {\n      helpers[k] = component[k].bind(component);\n    }\n  });\n\n  // Add plugins to helpers so they can be accessed in render expressions\n  helpers.plugins = plugins;\n\n  function resolveContext(el) {\n    let n = el;\n    while (n) {\n      const ctx = component._cloneContext.get(n);\n      if (ctx) {\n        if(component.getAttribute('logs') && component.getAttribute('logs').includes('plugins')) { console.log('Found context for element:', n, ctx); }\n        return ctx;\n      }\n      n = n.parentNode;\n    }\n    if(component.getAttribute('logs') && component.getAttribute('logs').includes('plugins')) {\n      console.log('Using default component context:', component);\n    }\n    return component;\n  }\n\n  function evaluate(expr, el) {\n    if (!expr) return true;\n    const ctx = resolveContext(el);\n    try {\n      return evalExpr(expr, { this: ctx, ...helpers });\n    } catch (e) {\n      warn(`[evaluate] \"${expr}\" failed in`, ctx, e);\n      return undefined;\n    }\n  }\n\n  function getValueFromPath(path, el) {\n    const ctx   = resolveContext(el);\n    const parts = path.match(/([^[.\\]]+)|\\[(\\d+)\\]/g);\n    if (!parts) return undefined;\n    return parts.reduce((acc, part) => {\n      if (acc == null) return undefined;\n      if (part.startsWith('[')) {\n        const i = parseInt(part.slice(1, -1), 10);\n        return Array.isArray(acc) ? acc[i] : undefined;\n      }\n      return acc[part];\n    }, ctx);\n  }\n\n  // ─── x-for ──────────────────────────────────────────────────────────────────\n  function parseXFor(expr) {\n    const re = /^\\s*(?:\\(\\s*([^,\\s]+)\\s*,\\s*([^,\\s]+)\\s*\\)|([^,\\s()]+))\\s+(?:in|of)\\s+(.+)$/;\n    const m  = expr.match(re);\n    if (!m) throw new Error('Invalid x-for: ' + expr);\n    return {\n      loopVar:   m[1] || m[3],\n      indexVar:  m[2] || null,\n      arrayPath: m[4].trim()\n    };\n  }\n\n  function createProxyContext(base, key, val, ikey, ival) {\n    return new Proxy(base, {\n      has(t,p){ return p===key || (ikey&&p===ikey) || p in t; },\n      get(t,p){\n        if (p===key)   return val;\n        if (ikey && p===ikey) return ival;\n        return t[p];\n      }\n    });\n  }\n\n  function tagWithContext(rootNode, ctx) {\n    component._cloneContext.set(rootNode, ctx);\n    rootNode.querySelectorAll('*').forEach(n =>\n      component._cloneContext.set(n, ctx)\n    );\n  }\n\n  const doXForLogs = doLogs && skipCleanup('for');\n  if (doXForLogs) console.groupCollapsed('x-for');\n\n  function deepSignature(arr) {\n    // You can use a more sophisticated hash if needed\n    return JSON.stringify(arr);\n  }\n\n  // collect x-for templates from both the DOM and the in-memory fragment\n  const tpls = Array.from(root.querySelectorAll('template[x-for]'))\n    .concat(Array.from(component.__mirrorContainer.querySelectorAll('template[x-for]')));\n  tpls.forEach(tpl => {\n    // keep template around to drive subsequent renders\n    if (!tpl._xForMeta) {\n      tpl._xForMeta = {\n        parent: tpl.parentNode,\n        next:   tpl.nextSibling\n      };\n      component.__mirrorContainer.appendChild(tpl);\n    }\n\n    // evaluate the array\n    let loopVar, indexVar, arrayPath;\n    try {\n      ({ loopVar, indexVar, arrayPath } =\n        parseXFor(tpl.getAttribute('x-for')));\n    } catch (e) {\n      warn('[x-for]', e.message);\n      return;\n    }\n\n    const arr = getValueFromPath(arrayPath, tpl);\n    if (!Array.isArray(arr)) {\n      warn(`[x-for] expected array at ${arrayPath}`, arr);\n      return;\n    }\n    if (doXForLogs) console.log(`iterating ${arrayPath} → length ${arr.length}`);\n\n    // --- PATCH: deep signature for deep change detection ---\n    const arrSignature = deepSignature(arr);\n    // compare with last run\n    const prev = component._xForCache.get(tpl);\n    if (prev && prev.arrayRef === arr && prev.length === arr.length && prev.signature === arrSignature) {\n      if (doXForLogs) console.log(`  → skipped (no change)`);\n      return;\n    }\n    // store new snapshot\n    component._xForCache.set(tpl, { arrayRef: arr, length: arr.length, signature: arrSignature });\n\n    // clear old clones\n    if (tpl._forClones) tpl._forClones.forEach(n => n.remove());\n    tpl._forClones = [];\n\n    // render fresh\n    arr.forEach((item, idx) => {\n      if (doXForLogs) console.groupCollapsed(`  index ${idx}`);\n      const frag = documentRef.createDocumentFragment();\n      frag.appendChild(tpl.content.cloneNode(true));\n\n      const proxy = createProxyContext( component, loopVar, item, indexVar, idx );\n      tagWithContext(frag, proxy);\n\n      // isolate render cache per iteration\n      const savedCache = component._xRenderCache;\n      const savedOriginal = component._xRenderOriginalText;\n      component._xRenderCache = new Map();\n      component._xRenderOriginalText = new WeakMap();\n\n      renderx.call(component, frag);\n\n      component._xRenderCache = savedCache;\n      component._xRenderOriginalText = savedOriginal;\n\n      // insert into place\n      while (frag.firstChild) {\n        const node = frag.firstChild;\n        tpl._xForMeta.parent.insertBefore(node, tpl._xForMeta.next);\n        tpl._forClones.push(node);\n      }\n      if (doXForLogs) console.groupEnd();\n    });\n  });\n\n  if (doXForLogs) console.groupEnd();\n\n\n  // ─── x-if ───────────────────────────────────────────────────────────────────\n  const doXIfLogs = doLogs && skipCleanup('if');\n  // process x-if in both live DOM and in-memory fragment\n  const xIfEls = Array.from(root.querySelectorAll('[x-if]'))\n    .concat(Array.from(component.__mirrorContainer.querySelectorAll('[x-if]')));\n  xIfEls.forEach(el => {\n    const expr = el.getAttribute('x-if')?.trim();\n    const show = expr ? evaluate(expr, el) : true;\n    if (doXIfLogs) console.groupCollapsed('x-if', el, expr, '→', show);\n\n    let d = component._xIfData.get(el);\n    if (!d) {\n      d = {\n        placeholder: documentRef.createComment('x-if placeholder'),\n        isHidden: false\n      };\n      component._xIfData.set(el, d);\n    }\n\n    if (!show && !d.isHidden) {\n      el.parentNode.replaceChild(d.placeholder, el);\n      component.__mirrorContainer.appendChild(el);\n      d.isHidden = true;\n    } else if (show && d.isHidden) {\n      d.placeholder.parentNode.replaceChild(el, d.placeholder);\n      d.isHidden = false;\n    }\n\n    if (doXIfLogs) console.groupEnd();\n  });\n\n\n  // ─── cache render EXPRESSIONS ────────────────────────────────────────────────\n  if (component._xRenderCache.size === 0) {\n    Array.from(root.querySelectorAll('[render]')).forEach(el => {\n      const e = el.getAttribute('render')?.trim();\n      if (e) {\n        component._xRenderCache.set(el, e);\n        component._xRenderOriginalText.set(el, el.textContent);\n      }\n    });\n  }\n\n  // ─── cache x-class DIRECTIVES ──────────────────────────────────────────────\n  Array.from(root.querySelectorAll('[x-class]')).forEach(el => {\n    const dir = el.getAttribute('x-class');\n    if (dir != null && !component._xClassCache.has(el)) {\n      component._xClassCache.set(el, dir);\n    }\n  });\n\n  // ─── x-attr (all other x-*) ───────────────────────────────────────────────\n  const doXAttrLogs = doLogs && skipCleanup('attr');\n  Array.from(root.querySelectorAll('*')).forEach(el => {\n    Array.from(el.attributes).forEach(attr => {\n      if (\n        attr.name.startsWith('x-') &&\n        !['x-for','x-key','x-class','x-if','x-hidden'].includes(attr.name)\n      ) {\n        const pluginName = attr.name;  // Keep full name for plugin lookup\n        const plugin = plugins.get(pluginName);\n        \n        if (plugin && (plugin.target === 'attribute')) {\n          // Execute attribute plugin\n          const value = evaluate(attr.value.trim(), el);\n          try {\n            if (doPluginsLogs) {\n              console.log('[plugin]', `Executing ${pluginName} with:`, { element: el, value, component });\n            }\n            plugin.execute(el, value, component);\n          } catch(e) {\n            if (doPluginsLogs) {\n              console.error('[plugin]', `Error executing ${pluginName}:`, e);\n            }\n          }\n        } else {\n          // Handle as regular x-attr\n          const real = attr.name.slice(2);\n          const v = evaluate(attr.value.trim(), el);\n          if (doXAttrLogs) {\n            console.groupCollapsed('x-attr', el, real, '=', v);\n          }\n          if (v) el.setAttribute(real, String(v));\n          else   el.removeAttribute(real);\n          if (doXAttrLogs) console.groupEnd();\n        }\n      }\n    });\n  });\n\n  // ─── x-class PROCESSING FROM CACHE ─────────────────────────────────────────\n  const doXClassLogs = doLogs && skipCleanup('class');\n  if (doXClassLogs) console.groupCollapsed('x-class');\n  for (const [el, txt] of component._xClassCache) {\n    if (doXClassLogs) console.log('element →', el);\n    const dir = txt.trim();\n    if (dir.includes('(')) {\n      // dynamic patterns: remove stale classes and apply new ones\n      const rx = /\\(\\s*([^,]+?)\\s*,\\s*([^)]+?)\\s*\\)/g;\n      // init dynamic cache\n      if (!component._xClassDynamicValues) component._xClassDynamicValues = new Map();\n      const prevClasses = component._xClassDynamicValues.get(el) || [];\n      // remove previously applied classes\n      prevClasses.forEach(cn => el.classList.remove(cn));\n      const newClasses = new Set();\n      let m;\n      while ((m = rx.exec(dir))) {\n        const clsExpr = m[1].trim();\n        const condExpr = m[2].trim();\n        let clsVal;\n        // if class expression is plain class names, use it directly\n        if (/^[\\w\\-\\s]+$/.test(clsExpr)) {\n          clsVal = clsExpr;\n        } else {\n          clsVal = evaluate(clsExpr, el);\n        }\n        const ok = Boolean(evaluate(condExpr, el));\n        let classes = [];\n        if (typeof clsVal === 'string') {\n          classes = clsVal.split(/\\s+/).filter(Boolean);\n        } else if (Array.isArray(clsVal)) {\n          classes = clsVal;\n        } else if (clsVal && typeof clsVal === 'object') {\n          classes = Object.keys(clsVal).filter(k => clsVal[k]);\n        }\n        if (ok) classes.forEach(cn => el.classList.add(cn));\n        classes.forEach(cn => newClasses.add(cn));\n        if (doXClassLogs) console.log(`  ${clsExpr} → [${classes.join(' ')}] (= ${ok})`);\n      }\n      component._xClassDynamicValues.set(el, Array.from(newClasses));\n    } else {\n      // Dynamic x-class: remove stale classes before applying\n      if (!component._xClassDynamicValues) component._xClassDynamicValues = new Map();\n      const prevDyn = component._xClassDynamicValues.get(el) || [];\n      prevDyn.forEach(cn => el.classList.remove(cn));\n      // Support full-expression (e.g., ternary) when no comma but contains '?' or ':'\n      let clsVal;\n      let ok = true;\n      if (!dir.includes(',') && /[?:]/.test(dir)) {\n        // Evaluate expression to get class string/array/object\n        clsVal = evaluate(dir, el);\n      } else {\n        // Default: split into class and condition\n        const idx = dir.indexOf(',');\n        const clsPart = idx>=0 ? dir.slice(0,idx).trim() : dir;\n        const condPart = idx>=0 ? dir.slice(idx+1).trim() : 'true';\n        ok = Boolean(evaluate(condPart, el));\n        clsVal = clsPart;\n      }\n      // Determine classes from clsVal\n      const classes = [];\n      if (typeof clsVal === 'string') {\n        classes.push(...clsVal.split(/\\s+/).filter(Boolean));\n      } else if (Array.isArray(clsVal)) {\n        classes.push(...clsVal);\n      } else if (clsVal && typeof clsVal === 'object') {\n        classes.push(...Object.keys(clsVal).filter(k => clsVal[k]));\n      }\n      // Apply or remove classes\n      classes.forEach(cn => {\n        if (ok) el.classList.add(cn);\n        else  el.classList.remove(cn);\n      });\n      if (doXClassLogs) console.log(`  x-class ${dir} →`, classes, `ok=${ok}`);\n      // Store dynamic classes for next render\n      component._xClassDynamicValues.set(el, classes);\n    }\n  }\n  if (doXClassLogs) console.groupEnd();\n\n\n  // ─── text render ──────────────────────────────────────────────────────────────\n  const doRenderLogs = doLogs && skipCleanup('render');\n  if (doRenderLogs) console.groupCollapsed('render');\n  for (const [el, expr] of component._xRenderCache) {\n    const dd = component._xIfData.get(el);\n    if (dd && dd.isHidden) continue;\n\n    if (doRenderLogs) console.log('element →', el, 'expr=', expr);\n    const ci = expr.indexOf(',');\n    const ve = ci<0 ? expr : expr.slice(0,ci).trim();\n    const ce = ci<0 ? 'true' : expr.slice(ci+1).trim();\n    const cond = evaluate(ce, el);\n    let out;\n    if (cond) {\n      let v = evaluate(ve, el);\n      if (v === undefined) {\n        // on error, preserve original text\n        out = component._xRenderOriginalText.get(el) || '';\n      } else if (v != null && typeof v==='object') {\n        try { out = JSON.stringify(v,null,2); }\n        catch { out = String(v); }\n      } else if (v == null) {\n        out = '';\n      } else {\n        out = typeof v==='boolean' ? '' : String(v);\n      }\n    } else {\n      out = component._xRenderOriginalText.get(el) || '';\n    }\n    if (el.textContent !== out) el.textContent = out;\n    if (doRenderLogs) console.log(`  → \"${out}\" (cond=${cond})`);\n  }\n  if (doRenderLogs) console.groupEnd();\n\n\n  // ─── CLEANUP ATTRIBUTES ───────────────────────────────────────────────────────\n  Array.from(root.querySelectorAll('*')).forEach(el => {\n    const dd = component._xIfData.get(el);\n    if (dd && dd.isHidden) return;\n\n    // remove only render attribute (keep x-if for dynamic toggling)\n    [['render','render']].forEach(([attr,feat])=>{\n      if (el.hasAttribute(attr) && !skipCleanup(feat)) {\n        el.removeAttribute(attr);\n      }\n    });\n    // preserve all other x-* directives (x-if, x-class, x-value, etc.) for dynamic updates\n  });\n\n  // ─── @event HANDLERS ──────────────────────────────────────────────────────────\n  // This must be last so it applies to all rendered elements, including those from x-for and slotted content\n  function attachEventHandlersToTree(rootOrNode) {\n    // Attach to all elements in the tree\n    Array.from(rootOrNode.querySelectorAll('*')).forEach(el => {\n      Array.from(el.attributes).forEach(attr => {\n        if (attr.name.startsWith('@')) {\n          const eventName = attr.name.slice(1);\n          const handlerExpr = attr.value.trim();\n\n          // Remove any previous listener to avoid duplicates\n          if (el._xEventListeners && el._xEventListeners[eventName]) {\n            el.removeEventListener(eventName, el._xEventListeners[eventName]);\n          }\n          if (!el._xEventListeners) el._xEventListeners = {};\n\n          // Compute merged context for event handlers\n          const ctx = resolveContext(el);\n          const mergedCtx = new Proxy(ctx, {\n            get(target, prop) {\n              if (prop in target) return target[prop];\n              return component[prop];\n            }\n          });\n\n          // Handler function using miniEvaluator\n          const handler = function(event) {\n            try {\n              return evalExpr(handlerExpr, { this: mergedCtx, event, ...helpers });\n            } catch (e) {\n              warn(`[renderx @${eventName}] Error evaluating: ${handlerExpr}`, e);\n            }\n          };\n\n          el.addEventListener(eventName, handler);\n          el._xEventListeners[eventName] = handler;\n        }\n      });\n    });\n    // For each slot, also process assigned elements recursively\n    Array.from(rootOrNode.querySelectorAll('slot')).forEach(slot => {\n      const assigned = slot.assignedElements ? slot.assignedElements({flatten: true}) : [];\n      assigned.forEach(assignedEl => {\n        attachEventHandlersToTree(assignedEl);\n      });\n    });\n  }\n  attachEventHandlersToTree(root);\n\n  // apply plugins after core rendering\n  processPlugins(root, component);\n}\n\n// chainable plugin registration\nrenderx.use = function(plugin) {\n  usePlugin(plugin);\n  return renderx;\n};\n\n// Export plugin API\nexport { plugins, usePlugin as use, parsePluginCall, processPlugins as process };\n\n// CommonJS export for compatibility\nif (typeof module !== 'undefined' && module.exports) {\n  module.exports = {\n    renderx,\n    use: usePlugin,\n    process: processPlugins,\n    plugins,\n    parsePluginCall\n  };\n}\n"],"names":["GLOBALS","Math","Date","Number","String","Boolean","JSON","parseInt","parseFloat","isFinite","Array","evalExpr","expr","ctx","tokens","str","i","length","ch","test","quote","val","push","type","value","start","num","slice","name","two","substr","three","includes","Error","tokenize","index","peek","next","expect","tok","undefined","isOperator","op","t","result","parseConditional","parseLogicalAnd","right","parseLogicalOr","trueVal","falseVal","parseEquality","parseRelational","parseAdditive","parseMultiplicative","parseUnary","this","resolveIdentifier","prop","idx","args","apply","parsePrimary","plugins","Map","usePlugin","plugin","set","parsePluginCall","call","m","match","get","argsString","trim","split","map","p","startsWith","endsWith","async","processPlugins","root","document","els","from","querySelectorAll","filter","el","attributes","some","a","attrName","rawValue","parsed","e","console","error","pluginName","onBeforeExecute","execute","textContent","onAfterExecute","values","onAfterRender","renderx","shadowRoot","component","onBeforeRender","documentRef","logsAttr","getAttribute","doLogs","logsSet","Set","s","toLowerCase","skipCleanup","feat","has","doPluginsLogs","warn","_xRenderCache","_xRenderOriginalText","WeakMap","_xIfData","_cloneContext","_xClassCache","_xForCache","__mirrorContainer","createDocumentFragment","helpers","resolveContext","n","log","parentNode","evaluate","Object","getOwnPropertyNames","getPrototypeOf","forEach","k","bind","doXForLogs","groupCollapsed","concat","tpl","loopVar","indexVar","arrayPath","_xForMeta","parent","nextSibling","appendChild","parseXFor","message","arr","path","parts","reduce","acc","part","isArray","getValueFromPath","arrSignature","stringify","deepSignature","prev","arrayRef","signature","_forClones","remove","item","frag","content","cloneNode","proxy","key","ikey","ival","Proxy","rootNode","savedCache","savedOriginal","firstChild","node","insertBefore","groupEnd","doXIfLogs","show","d","placeholder","createComment","isHidden","replaceChild","size","dir","doXAttrLogs","attr","target","element","real","v","setAttribute","removeAttribute","doXClassLogs","txt","rx","_xClassDynamicValues","cn","classList","newClasses","exec","clsExpr","condExpr","clsVal","ok","classes","keys","add","join","indexOf","clsPart","condPart","doRenderLogs","dd","ci","ve","cond","out","hasAttribute","attachEventHandlersToTree","rootOrNode","eventName","handlerExpr","_xEventListeners","removeEventListener","mergedCtx","handler","event","addEventListener","slot","assignedElements","flatten","assignedEl","use","module","exports","process"],"mappings":"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"}